open Utility

module StrMap = Map.Make(String)

type berk_t =
  | U64
  | U32
  | U16
  | U8
  | I64
  | I32
  | I16
  | I8
  | F128
  | F64
  | F32
  | Bool
  | String
  | Nil
  | Tuple of berk_t list
  | Array of berk_t * int
  | Variant of string * v_ctor list
      (*
        Variant("Option", [("Some", Unbound("`a")); (None, Nil)])
      *)
  | Ptr of berk_t
  (* This is not generated by the front-end, but may be generated during the
  MIR transform to indicate "the type of this data is actually the [N x i8] raw
  form of this type. " *)
  | ByteArray of berk_t
  | Function of berk_t * berk_t list
  | VarArgSentinel

  (* A user-defined type, that we're not sure what it is yet. Typically
  generated during parse and resolved during typecheck.

  The first field is the type name, and the second is the possibly-empty list of
  template instantiation parameters.
  *)
  | UnboundType of string * berk_t list

  (* A type variable, a la `t *)
  | Unbound of string

  | Undecided

and v_ctor = {name: string; fields: v_ctor_field list}

and v_ctor_field = {t: berk_t}

let rec fmt_join_types ?(pretty_unbound=false) delim types =
  match types with
  | [] -> ""
  | [x] -> fmt_type ~pretty_unbound:pretty_unbound x
  | x::xs ->
      let lhs = fmt_type ~pretty_unbound:pretty_unbound x in
      lhs ^ delim ^ (fmt_join_types ~pretty_unbound:pretty_unbound delim xs)

and fmt_type ?(pretty_unbound=false) berk_type : string =
  match berk_type with
  | U64 -> "u64"
  | U32 -> "u32"
  | U16 -> "u16"
  | U8  -> "u8"
  | I64 -> "i64"
  | I32 -> "i32"
  | I16 -> "i16"
  | I8  -> "i8"
  | F128 -> "f128"
  | F64  -> "f64"
  | F32  -> "f32"
  | Bool -> "bool"
  | String -> "string"
  | Nil -> "()"
  | Array (typ, sz) ->
      let sz_s = Printf.sprintf "%d" sz in
      "[" ^ (fmt_type ~pretty_unbound:pretty_unbound typ) ^ " x " ^ sz_s ^ "]"
  | Tuple (types) ->
      "(" ^ (fmt_join_types ~pretty_unbound:pretty_unbound ", " types) ^ ")"
  | Variant (type_name, variant_ctors) ->
      let ctor_fmts = List.map fmt_v_ctor variant_ctors in
      let variants_fmt = fmt_join_strs " | " ctor_fmts in

      Printf.sprintf "variant %s {%s}" type_name variants_fmt

  | Ptr (typ) ->
      Printf.sprintf "ptr %s"
        (fmt_type ~pretty_unbound:pretty_unbound typ)

  | ByteArray (typ) ->
      Printf.sprintf "bytesof(%s)"
        (fmt_type ~pretty_unbound:pretty_unbound typ)

  | Function (ret_t, arg_t_lst) ->
      Printf.sprintf "(%s)->%s"
        (fmt_join_types ~pretty_unbound:pretty_unbound ", " arg_t_lst)
        (fmt_type ~pretty_unbound:pretty_unbound ret_t)

  | VarArgSentinel -> "..."

  | UnboundType(name, ts) ->
      let ts_fmt =
        if List.length ts = 0 then
          ""
        else
          "<" ^ (fmt_join_types ~pretty_unbound:pretty_unbound ", " ts) ^ ">"
      in
      Printf.sprintf "%s:(unbound-type)%s"
        name
        ts_fmt

  | Unbound (type_var) ->
      if pretty_unbound
      then type_var
      else "<?unbound:" ^ type_var ^ "?>"
  | Undecided -> "<?undecided?>"

and fmt_v_ctor ?(pretty_unbound=false) {name; fields} : string =
  let fields_fmt =
    begin match fields with
    | [] -> ""
    | _ ->
        let fields_fmt =
          List.map (
            fun {t} -> fmt_type ~pretty_unbound:pretty_unbound t
          ) fields
        in
        Printf.sprintf "(%s)" (fmt_join_strs ", " fields_fmt)
    end
  in
  Printf.sprintf "%s%s" name fields_fmt
;;

let pprint_berk_t ppf berk_type =
  Format.fprintf ppf "%s" (fmt_type ~pretty_unbound:true berk_type)
;;

type var_qual = {
  mut: bool;
}

let fmt_var_qual {mut} =
  if mut then "mut " else ""
;;


let def_var_qual = {mut = false}

(* Determine the common type between two. ie, if they're not the same type, but
one is convertible to the other, yield the common type. *)
let rec common_type_of_lr lhs rhs =
  let _common_type_of_lr lhs rhs =
    match (lhs, rhs) with
    | (Undecided, Undecided) -> Some(Undecided)

    | (Unbound(_), Undecided)
    | (Undecided, Unbound(_)) ->
        failwith "Nonsense mapping from unbound typevar to undecided type"

    | (_,         Undecided) -> Some(lhs)
    | (Undecided,         _) -> Some(rhs)

    | (Nil,              Nil) -> Some(Nil)
    | ((I64|I32|I16|I8), I64) -> Some(I64)
    | ((I32|I16|I8),     I32) -> Some(I32)
    | ((I16|I8),         I16) -> Some(I16)
    | (I8,               I8 ) -> Some(I8)
    | ((U64|U32|U16|U8), U64) -> Some(U64)
    | ((U32|U16|U8),     U32) -> Some(U32)
    | ((U16|U8),         U16) -> Some(U16)
    | (U8,               U8 ) -> Some(U8)
    | ((F128|F64|F32),  F128) -> Some(F128)
    | ((F64|F32),       F64 ) -> Some(F64)
    | (F32,             F32 ) -> Some(F32)
    | (Bool,            Bool) -> Some(Bool)
    | (String,        String) -> Some(String)

    | (Unbound(lhs_typevar), Unbound(rhs_typevar)) ->
        if lhs_typevar = rhs_typevar then
          Some(Unbound(lhs_typevar))
        else
          None

    | (Unbound(_), _) -> Some(rhs)
    | (_, Unbound(_)) -> Some(lhs)

    | (Tuple(lhs_typs), Tuple(rhs_typs)) ->
        let common_tup_typs = List.map2 common_type_of_lr lhs_typs rhs_typs in
        Some(Tuple(common_tup_typs))

    | (Array(lhs_elem_typ, lhs_sz), Array(rhs_elem_typ, rhs_sz)) ->
        if lhs_sz = rhs_sz then
          let common_elem_typ = common_type_of_lr lhs_elem_typ rhs_elem_typ in
          Some(Array(common_elem_typ, lhs_sz))
        else
          None

    | (Variant(lhs_name, lhs_ctor_lst), Variant(rhs_name, rhs_ctor_lst)) ->
        if lhs_name = rhs_name then
          if (List.compare_lengths lhs_ctor_lst rhs_ctor_lst) = 0 then
            let common_ctors =
              List.map2 common_v_ctor lhs_ctor_lst rhs_ctor_lst
            in
            Some(Variant(lhs_name, common_ctors))
          else
            None
        else
          None

    | _ -> None
  in
  match _common_type_of_lr lhs rhs with
  | Some(t) -> t
  | None ->
    match _common_type_of_lr rhs lhs with
    | Some(t) -> t
    | None ->
        let lhs_fmt = fmt_type lhs in
        let rhs_fmt = fmt_type rhs in
        failwith (
          "No common type between [[" ^ lhs_fmt ^ "]] [[" ^ rhs_fmt ^ "]]"
        )

(* Helper function for determining the "common" variant ctor between two. *)
and common_v_ctor_opt
  {name=lhs_name; fields=lhs_fields}
  {name=rhs_name; fields=rhs_fields} : v_ctor option
=
  if
    lhs_name <> rhs_name || List.length lhs_fields <> List.length rhs_fields
  then
    None
  else
    let common_fields =
      List.map2 (
        fun {t=lhs_t} {t=rhs_t} ->
          let common_t = common_type_of_lr lhs_t rhs_t in
          {t=common_t}
      ) lhs_fields rhs_fields
    in
    Some({name=lhs_name; fields=common_fields})

and common_v_ctor lhs_ctor rhs_ctor : v_ctor =
  let common_ctor_opt = common_v_ctor_opt lhs_ctor rhs_ctor in
  begin match common_ctor_opt with
  | Some(ctor) -> ctor
  | None ->
      failwith (
        Printf.sprintf
          "Failed to unify fields of variant ctors: [%s] vs [%s]"
          (fmt_v_ctor lhs_ctor)
          (fmt_v_ctor rhs_ctor)
      )
  end

and common_type_of_lst lst =
  match lst with
  | [] -> Nil
  | [x] -> x
  | x::xs -> List.fold_left common_type_of_lr x xs
;;

let rec type_convertible_to from_t to_t =
  (* Helper function for determining if an individual variant ctor is
  implicitly convertible to another. *)
  let _v_ctor_convertible_to
    {name=lhs_name; fields=lhs_fields}
    {name=rhs_name; fields=rhs_fields} : bool
  =
    if
      lhs_name <> rhs_name || List.length lhs_fields <> List.length rhs_fields
    then
      false
    else
      let agreements =
        List.map2 (
          fun {t=lhs_t} {t=rhs_t} ->
            type_convertible_to lhs_t rhs_t
        ) lhs_fields rhs_fields
      in
      List.fold_left (&&) true agreements
  in

  match (from_t, to_t) with
  | (_, Unbound(_)) -> true
  | (Unbound(_), _) -> true

  | (I64, I64)
  | (I32, I64)
  | (I16, I64)
  | (I8,  I64)
  | (I32, I32)
  | (I16, I32)
  | (I8,  I32)
  | (I16, I16)
  | (I8,  I16)
  | (I8,  I8) -> true

  | (U64, U64)
  | (U32, U64)
  | (U16, U64)
  | (U8,  U64)
  | (U32, U32)
  | (U16, U32)
  | (U8,  U32)
  | (U16, U16)
  | (U8,  U16)
  | (U8,  U8) -> true

  | (F128, F128)
  | (F64, F128)
  | (F32, F128)
  | (F64, F64)
  | (F32, F64)
  | (F32, F32) -> true

  | (String, String) -> true
  | (Bool, Bool) -> true
  | (Nil, Nil) -> true

  | (Function(lhs_ret_t, lhs_args_ts), Function(rhs_ret_t, rhs_args_ts)) ->
      let ret_t_convertible = type_convertible_to lhs_ret_t rhs_ret_t in
      let args_ts_convertible =
        List.fold_left (=) true (
          List.map2 type_convertible_to lhs_args_ts rhs_args_ts
        )
      in
      if ret_t_convertible && args_ts_convertible then true else false

  | (Tuple(lhs_types), Tuple(rhs_types)) ->
      if (List.length lhs_types) <> (List.length rhs_types)
        then false
        else begin
          let agreements = List.map2 type_convertible_to lhs_types rhs_types in
          List.fold_left (&&) true agreements
        end

  | Array(lhs_elem_typ, lhs_sz), Array(rhs_elem_typ, rhs_sz) ->
      lhs_sz = rhs_sz &&
      type_convertible_to lhs_elem_typ rhs_elem_typ

  | Variant(lhs_v_name, lhs_ctors), Variant(rhs_v_name, rhs_ctors) ->
      if lhs_v_name = rhs_v_name
      then
        if List.length lhs_ctors = List.length rhs_ctors
        then
          let agreements =
            List.map2 _v_ctor_convertible_to lhs_ctors rhs_ctors
          in
          List.fold_left (&&) true agreements
        else false
      else false

  | _ ->
      let from_t_s = fmt_type from_t in
      let to_t_s = fmt_type to_t in
      begin
        Printf.printf "Cannot convert [%s] to [%s]\n" from_t_s to_t_s;
        false
      end
;;


let type_extendable_to from_t to_t =
  match (from_t, to_t) with
  | (I32, I64)
  | (I16, I64)
  | (I16, I32)
  | (I8,  I64)
  | (I8,  I32)
  | (I8,  I16) -> true

  | (U32, U64)
  | (U16, U64)
  | (U16, U32)
  | (U8,  U64)
  | (U8,  U32)
  | (U8,  U16) -> true

  | (F64, F128)
  | (F32, F128)
  | (F32, F64) -> true

  | _ ->
      let from_t_s = fmt_type from_t in
      let to_t_s = fmt_type to_t in
      begin
        Printf.printf "Cannot extend [%s] to [%s]\n" from_t_s to_t_s;
        false
      end
;;


let type_truncatable_to from_t to_t =
  match (from_t, to_t) with
  | (I64, I32)
  | (I64, I16)
  | (I64, I8)
  | (I32, I16)
  | (I32, I8)
  | (I16, I8) -> true

  | (U64, U32)
  | (U64, U16)
  | (U64, U8)
  | (U32, U16)
  | (U32, U8)
  | (U16, U8) -> true

  | (F128, F64)
  | (F128, F32)
  | (F64, F32) -> true

  | _ ->
      let from_t_s = fmt_type from_t in
      let to_t_s = fmt_type to_t in
      begin
        Printf.printf "Cannot truncate [%s] to [%s]\n" from_t_s to_t_s;
        false
      end
;;


let type_bitwise_to from_t to_t =
  match (from_t, to_t) with
  | (I64, U64)
  | (U64, I64) -> true

  | (I32, U32)
  | (U32, I32) -> true

  | (I16, U16)
  | (U16, I16) -> true

  | (I8, U8)
  | (U8, I8) -> true

  | _ ->
      let from_t_s = fmt_type from_t in
      let to_t_s = fmt_type to_t in
      begin
        Printf.printf "Cannot bitwise cast [%s] to [%s]\n" from_t_s to_t_s;
        false
      end
;;


(* Retrieve a variant constructor by name from the given variant type. *)
let get_v_ctor_opt v_t ctor_name : v_ctor option =
  begin match v_t with
  | Variant(_, v_ctors) ->
      List.find_opt (
        fun {name; _} -> name = ctor_name
      ) v_ctors
  | _ -> None
  end
;;


let has_v_ctor v_t ctor_name : bool =
  let ctor_opt = get_v_ctor_opt v_t ctor_name in
  begin match ctor_opt with
  | Some(_) -> true
  | None -> false
  end
;;


(* Retrieve a variant constructor by name from the given variant type. *)
let get_v_ctor v_t ctor_name : v_ctor =
  let ctor_opt = get_v_ctor_opt v_t ctor_name in
  begin match ctor_opt with
  | Some(v_ctor) -> v_ctor
  | None ->
      failwith (
        Printf.sprintf "Variant type [%s] has no constructor [%s]"
          (fmt_type v_t)
          ctor_name
      )
  end
;;


let get_v_ctor_fields v_t ctor_name : v_ctor_field list =
  let {fields; _} = get_v_ctor v_t ctor_name in
  fields
;;


let get_v_ctor_fields_ts v_t ctor_name : berk_t list =
  let fields = get_v_ctor_fields v_t ctor_name in
  let ts = List.map (fun {t} -> t) fields in
  ts
;;


(* Returns true if the given type is a variant such that all of its constructors
have zero fields (ie, a C-style enum). Returns false otherwise. *)
let rec is_zero_field_variant t : bool =
  begin match t with
  | Variant(_, v_ctors) ->
      let each_ctor_empty = List.map is_zero_field_v_ctor v_ctors in
      let all_ctors_empty = List.fold_left (&&) true each_ctor_empty in
      all_ctors_empty

  | _ -> false
  end

and is_zero_field_v_ctor {fields; _} =
  match fields with
  | [] -> true
  | _ -> false
;;


(* Return true if the two variant ctors approximately match.  *)
let v_ctors_match lhs_ctor rhs_ctor =
  (* TODO: This is broken. This can lead to a superset type apparently matching
  a subset type. *)
  let common_ctor_opt = common_v_ctor_opt lhs_ctor rhs_ctor in
  begin match common_ctor_opt with
  | Some(_) -> true
  | None -> false
  end
;;


(* Build a bare-bones variant constructor record, based on the name and the
possibly-empty list of raw types that constitute the constructor fields. *)
let build_ctor_from_ts name ts : v_ctor =
  let fields = List.map (fun t -> {t}) ts in
  {name; fields}
;;


let get_tuple_of_ctor {fields; _} : berk_t =
  let ts = List.map (fun {t} -> t) fields in
  Tuple(ts)
;;


(* TODO: This is not the most appropriate place for this function, because
really the backend code generator (eg, LLVM) should be the one making decisions
about the relative sizes of types (particularly because of alignment between
fields in aggregate types). We keep this here now while we lack a sufficient
abstraction mechanism to punt this to the backend side. *)
let rec sizeof_type t =
  begin match t with
  | Function(_, _) -> 16
  (* FIXME: Not true yet, but will be if/when function ptrs become fat ptrs. *)
  | F128 -> 16
  | Ptr(_) -> 8
  | U64 | I64 | F64 -> 8
  | U32 | I32 | F32 -> 4
  | U16 | I16 -> 2
  | U8  | I8 -> 1
  | String -> 4
  | Bool -> 1
  | Nil -> 0

  | Tuple(ts) -> sum (List.map sizeof_type ts)
  | Array(t, sz) -> sz * (sizeof_type t)
  | Variant(_, ctors) ->
      let ctor_tuples = List.map get_tuple_of_ctor ctors in
      let ctor_tuple_sizes = List.map sizeof_type ctor_tuples in
      let max_ctor_size = List.fold_left max 0 ctor_tuple_sizes in
      (* Add 1 byte for the hidden variant ctor "tag". *)
      (1 + max_ctor_size)

  | ByteArray(t) -> sizeof_type t

  | VarArgSentinel
  | UnboundType(_, _)
  | Unbound(_)
  | Undecided ->
      failwith (
        Printf.sprintf "Invalid to attempt sizeof_type([%s])" (fmt_type t)
      )
  end


(* Return the Tuple representation of the largest ctor in the given variant.

TODO: This makes assumptions about target machine representation of these types,
which is not valid. Really, this function should be owned by the codegen side,
but we need a suitable abstraction layer to make that work (MIR sizeof?)
*)
let get_largest_ctor_tuple_of_variant v_t =
  begin match v_t with
  | Variant(_, ctors) ->
      let ctor_tuples = List.map get_tuple_of_ctor ctors in
      let largest_ctor_tuple =
        List.fold_left (
          fun lhs rhs ->
            begin if sizeof_type lhs > sizeof_type rhs then
              lhs
            else
              rhs
            end
        ) (Tuple([])) ctor_tuples
      in
      largest_ctor_tuple

  | _ ->
      failwith (
        Printf.sprintf
          "Cannot get_largest_ctor_tuple_of_variant of non-variant [%s]"
          (fmt_type v_t)
      )
  end
;;


let is_index_type idx_t =
  match idx_t with
  | I64
  | I32
  | I16
  | I8
  | U64
  | U32
  | U16
  | U8 -> true
  | _ ->
      let not_idx_s = fmt_type idx_t in
      Printf.printf "Cannot index into array with type [%s]\n" not_idx_s;
      false
;;


let is_indexable_type arr_t =
  match arr_t with
  | Ptr(_) -> true
  | Array(_, _) -> true
  | _ ->
      let not_arr_s = fmt_type arr_t in
      Printf.printf "Type [%s] is not indexable\n" not_arr_s;
      false
;;


let unwrap_indexable indexable_t =
  match indexable_t with
  | Array(t, _) -> t
  | _ ->
      failwith (
        Printf.sprintf "Cannot unwrap non-indexable type: [%s]"
          (fmt_type indexable_t)
      )
;;


let unwrap_aggregate_indexable indexable_t i =
  match indexable_t with
  | Tuple(ts) ->
      if i < List.length ts then
        List.nth ts i
      else
        failwith (Printf.sprintf "Invalid index into tuple of arity [%d]" i)

  | _ ->
      failwith (
        Printf.sprintf "Cannot unwrap non-indexable aggregate type: [%s]"
          (fmt_type indexable_t)
      )
;;


let unwrap_ptr ptr_t =
  match ptr_t with
  | Ptr(t) -> t
  | Array(t, _) -> t
  | _ ->
      failwith (
        Printf.sprintf "Cannot unwrap non-ptr type [%s]" (fmt_type ptr_t)
      )
;;


let is_unwrappable ptr_t =
  match ptr_t with
  | Ptr(_) -> true
  | _ -> false
;;


(* Make concrete the given type, to the extent possible, via the mappings in the
given string-type-variable-to-type mapping. *)
let rec concretify_unbound_types (tvar_to_t : berk_t StrMap.t) typ =
  (* Helper function for concretifying an individual variant ctor. *)
  let _concretify_v_ctor (tvar_to_t : berk_t StrMap.t) {name; fields} : v_ctor =
    let concrete_fields =
      List.map (
        fun {t} ->
          let concrete_t = concretify_unbound_types tvar_to_t t in
          {t=concrete_t}
      ) fields
    in
    {name; fields=concrete_fields}
  in

  match typ with
  | U64  | U32 | U16 | U8
  | I64  | I32 | I16 | I8
  | F128 | F64 | F32
  | Bool
  | String
  | Nil
  | VarArgSentinel
  | Undecided -> typ

  | Unbound(tvar) ->
      begin match (StrMap.find_opt tvar tvar_to_t) with
      | None -> Unbound(tvar)
      | Some(t) -> t
      end

  | UnboundType(name, ts) ->
      let ts_concrete = List.map (concretify_unbound_types tvar_to_t) ts in
      UnboundType(name, ts_concrete)

  | Ptr(pointed_t) ->
      let pointed_concretified_t =
        concretify_unbound_types tvar_to_t pointed_t
      in

      Ptr(pointed_concretified_t)

  | ByteArray(actual_t) ->
      let actual_concretified_t =
        concretify_unbound_types tvar_to_t actual_t
      in

      ByteArray(actual_concretified_t)

  | Tuple(tuple_typs) ->
      let typs_concretified =
        List.map (concretify_unbound_types tvar_to_t) tuple_typs
      in

      Tuple(typs_concretified)

  | Array(arr_typ, sz) ->
      let arr_typ_concretified = concretify_unbound_types tvar_to_t arr_typ in
      Array(arr_typ_concretified, sz)

  | Variant(v_name, v_ctors) ->
      let v_ctors_concretified =
        List.map (_concretify_v_ctor tvar_to_t) v_ctors
      in
      Variant(v_name, v_ctors_concretified)

  | Function(ret_t, args_t_lst) ->
      let ret_t = concretify_unbound_types tvar_to_t ret_t in
      let args_t_lst =
        List.map (concretify_unbound_types tvar_to_t) args_t_lst
      in

      Function(ret_t, args_t_lst)
;;

(* Returns true if the type is entirely resolved to a concrete (instantiable)
type, else false. *)
let rec is_concrete_type ?(verbose=false) typ =
  (* Helper function for determining if all fields in a variant ctor are
  concrete. *)
  let _is_concrete_v_ctor ({fields; _} : v_ctor) =
    let each_field =
      List.map (
        fun {t} -> is_concrete_type t
      ) fields
    in
    let all_fields = List.fold_left (&&) true each_field in
    all_fields
  in

  let _is_concrete_type typ = is_concrete_type ~verbose:verbose typ in

  let res = begin match typ with
  | Undecided  -> false
  | Unbound(_) -> false
  | UnboundType(_, _) -> false

  | U64  | U32 | U16 | U8
  | I64  | I32 | I16 | I8
  | F128 | F64 | F32
  | Bool
  | String
  | Nil -> true

  | Ptr(pointed_t) -> _is_concrete_type pointed_t

  | ByteArray(actual_t) -> _is_concrete_type actual_t

  | VarArgSentinel -> true

  | Tuple(tuple_typs) ->
      List.fold_left (&&) true (List.map _is_concrete_type tuple_typs)

  | Array(elem_typ, _) ->
      _is_concrete_type elem_typ

  | Variant(_, v_ctors) ->
      let each_ctor = List.map _is_concrete_v_ctor v_ctors in
      let all_ctors = List.fold_left (&&) true each_ctor in
      all_ctors

  | Function(ret_t, args_t_lst) ->
      let ret_concrete = _is_concrete_type ret_t in
      let args_concrete =
        List.fold_left (&&) true (List.map _is_concrete_type args_t_lst)
      in
      if ret_concrete && args_concrete then true else false

  end in

  let _ = if verbose then
    Printf.printf "is_concrete_type[[ %s ]] == %B\n%!" (fmt_type typ) res
  else
    ()
  in

  res
;;

(* Given two types that are expected to be structurally "symmetric", attempt to
"merge" the types. This means if an element of one type is undecided, but an
element of the other type is concrete, then the resultant type reflects the
concrete side. *)
let rec merge_types lhs_orig_t rhs_orig_t : berk_t =
  (* Helper function for merge two individual variant constructors. *)
  let _merge_v_ctors
    ({name=lhs_name; fields=lhs_fields} as lhs)
    ({name=rhs_name; fields=rhs_fields} as rhs)
  =
    if
      lhs_name <> rhs_name || List.length lhs_fields <> List.length rhs_fields
    then
      failwith (
        Printf.sprintf "Cannot merge variant constructors: [%s] vs [%s]"
          (fmt_v_ctor lhs)
          (fmt_v_ctor rhs)
      )
    else
      let merged_fields =
        List.map2 (
          fun {t=lhs_t} {t=rhs_t} ->
            let merged_field = merge_types lhs_t rhs_t in
            {t=merged_field}
        ) lhs_fields rhs_fields
      in
      {name=lhs_name; fields=merged_fields}
  in

  let rec _merge_types lhs_t rhs_t : berk_t =
    begin match (lhs_t, rhs_t) with
    | (Undecided, Undecided) ->
        Undecided

    (* Sanity check that unbound typevars agree with each other. *)
    | (Unbound(a), Unbound(b)) ->
        begin if a = b then
          Unbound(a)
        else
          failwith (
            Printf.sprintf "Cannot merge types: [%s] vs [%s]"
              (fmt_type lhs_orig_t) (fmt_type rhs_orig_t)
          )
        end

    (* We're not in the business of assigning types to unbound typevars. *)
    | (Unbound(_), _)
    | (_, Unbound(_)) ->
        failwith (
          Printf.sprintf
            "Unimplemented: Merging unbound vs bound types: [%s] vs [%s]"
            (fmt_type lhs_orig_t) (fmt_type rhs_orig_t)
        )

    (* The critical case: Defer to the concrete side if only one side is
    undecided. *)
    | (Undecided, _) -> rhs_t
    | (_, Undecided) -> lhs_t

    (* Base cases. *)
    | (U64, U64)   -> U64
    | (U32, U32)   -> U32
    | (U16, U16)   -> U16
    | (U8,  U8)    -> U8
    | (I64, I64)   -> I64
    | (I32, I32)   -> I32
    | (I16, I16)   -> I16
    | (I8,  I8)    -> I8
    | (F128, F128) -> F128
    | (F64,  F64)  -> F64
    | (F32,  F32)  -> F32
    | (Bool, Bool) -> Bool
    | (Nil,  Nil)  -> Nil
    | (String, String) -> String
    | (VarArgSentinel, VarArgSentinel) -> VarArgSentinel

    | (Ptr(lhs_t), Ptr(rhs_t)) ->
        let merged_t = _merge_types lhs_t rhs_t in
        Ptr(merged_t)

    | (ByteArray(lhs_t), ByteArray(rhs_t)) ->
        let merged_t = _merge_types lhs_t rhs_t in
        ByteArray(merged_t)

    | (Tuple(lhs_ts), Tuple(rhs_ts)) ->
        let merged_ts = List.map2 _merge_types lhs_ts rhs_ts in
        Tuple(merged_ts)

    | (Array(lhs_t, lhs_sz), Array(rhs_t, rhs_sz)) ->
        begin if lhs_sz = rhs_sz then
          let merged_t = _merge_types lhs_t rhs_t in
          Array(merged_t, lhs_sz)
        else
          failwith (
            Printf.sprintf
              "Cannot merge types: [%s] vs [%s]"
              (fmt_type lhs_orig_t) (fmt_type rhs_orig_t)
          )
        end

    | (Function(lhs_ret_t, lhs_arg_ts), Function(rhs_ret_t, rhs_arg_ts)) ->
        let merged_ret_t = _merge_types lhs_ret_t rhs_ret_t in
        let merged_arg_ts = List.map2 _merge_types lhs_arg_ts rhs_arg_ts in
        Function(merged_ret_t, merged_arg_ts)

    | (
        Variant(lhs_name, lhs_ctors),
        Variant(rhs_name, rhs_ctors)
      ) ->
        begin if
          lhs_name <> rhs_name ||
          List.length lhs_ctors <> List.length rhs_ctors
        then
          failwith (
            Printf.sprintf
              "Cannot merge types: [%s] vs [%s]"
              (fmt_type lhs_orig_t) (fmt_type rhs_orig_t)
          )
        else
          let merged_v_ctors = List.map2 _merge_v_ctors lhs_ctors rhs_ctors in
          Variant(lhs_name, merged_v_ctors)
        end

    | _ ->
        failwith (
          Printf.sprintf
            "Cannot merge types: [%s] vs [%s]"
            (fmt_type lhs_orig_t) (fmt_type rhs_orig_t)
        )
    end
  in

  _merge_types lhs_orig_t rhs_orig_t
;;


(* Given two types, each possibly some degree short of concrete, return a
mapping from the string-type-variables in one to their corresponding concrete
types in the other.

Fails if the given types are not structurally identical, ie, matching aggregrate
structure and component types at least one-way convertible. *)
let map_tvars_to_types
  ?(init_map=StrMap.empty) lhs_typ rhs_typ : berk_t StrMap.t
=
  (* Helper function for extracting the type variables referenced in variant
  constructors. *)
  let rec _map_tvars_to_types_in_v_ctor
    map_so_far {fields=lhs_fields; _} {fields=rhs_fields; _}
  =
    List.fold_left2 (
      fun so_far {t=lhs_t} {t=rhs_t} ->
        _map_tvars_to_types so_far lhs_t rhs_t
    ) map_so_far lhs_fields rhs_fields

  and _map_tvars_to_types map_so_far lhs_typ rhs_typ =
    match lhs_typ, rhs_typ with
    | (Unbound(lhs_tvar), Unbound(rhs_tvar)) ->
        (* Sanity check: These mappings from type-variable to concrete type are
        only sane if there is agreement between the two types on structurally
        _where_ specific type variables could exist. *)
        if lhs_tvar = rhs_tvar then
          map_so_far
        else
          failwith "Types disagree on structural location of tvars"

    | (Unbound(_), Undecided)
    | (Undecided, Unbound(_)) ->
        (* Don't record a mapping from a type variable to an undecided type. *)
        map_so_far

    | (Unbound(tvar), concrete_t)
    | (concrete_t, Unbound(tvar)) ->
        (*  The critical pattern: If one type has an unbound type variable and
        the other has a concrete type, then we can add that mapping to our
        collection. *)
        begin if is_concrete_type concrete_t then
          match (StrMap.find_opt tvar map_so_far) with
          | None -> StrMap.add tvar concrete_t map_so_far
          | Some(already_concrete_t) ->
              let common_concrete_t =
                common_type_of_lr concrete_t already_concrete_t
              in
              StrMap.add tvar common_concrete_t map_so_far
        else
          map_so_far
        end

    (* Nothing to be gleaned when we don't know what the type is expected to
    be at all, let alone mapping to a type variable. *)
    | (Undecided, Undecided) ->
        map_so_far

    (* If one side or the other is undecided, then assume that the other side
    is the correct type. Since neither side is unbound, just return the map. *)
    | (Undecided, _)
    | (_, Undecided) ->
        map_so_far

    | ( (U64|U32|U16|U8), (U64|U32|U16|U8))
    | ( (I64|I32|I16|I8), (I64|I32|I16|I8))
    | ((F128|F64|F32),   (F128|F64|F32))
    | (Bool, Bool)
    | (String, String)
    | (Nil, Nil)
    | (VarArgSentinel, VarArgSentinel) ->
        map_so_far

    | (Function(lhs_ret_t, lhs_args_ts), Function(rhs_ret_t, rhs_args_ts)) ->
        let map_so_far = _map_tvars_to_types map_so_far lhs_ret_t rhs_ret_t in
        List.fold_left2 _map_tvars_to_types map_so_far lhs_args_ts rhs_args_ts

    | (Tuple(lhs_typs), Tuple(rhs_typs)) ->
        List.fold_left2 _map_tvars_to_types map_so_far lhs_typs rhs_typs

    | (Array(lhs_typ, _), Array(rhs_typ, _)) ->
        _map_tvars_to_types map_so_far lhs_typ rhs_typ

    | (Variant(_, lhs_ctors), Variant(_, rhs_ctors)) ->
        List.fold_left2
          _map_tvars_to_types_in_v_ctor map_so_far lhs_ctors rhs_ctors

    | _ ->
        let lhs_fmt = fmt_type lhs_typ in
        let rhs_fmt = fmt_type rhs_typ in
        failwith (
          "Called with non-structurally-identical types: [[ " ^
          lhs_fmt ^ " ]] vs [[ " ^ rhs_fmt ^ " ]]"
        )

  in
  _map_tvars_to_types init_map lhs_typ rhs_typ
;;

(* Given a type, return a list of all of the string type variables. *)
let get_tvars typ =
  (* Helper function for extracting the type variables out of an individual
  variant constructor *)
  let rec _get_tvars_in_v_ctor so_far {fields; _} =
    List.fold_left (
      fun so_far {t} ->
        _get_tvars so_far t
    ) so_far fields

  and _get_tvars so_far typ =
    match typ with
    | Unbound(tvar) -> tvar :: so_far

    | UnboundType(_, ts) ->
        List.fold_left _get_tvars so_far ts

    | U64  | U32 | U16 | U8
    | I64  | I32 | I16 | I8
    | F128 | F64 | F32
    | Bool
    | String
    | Nil
    | VarArgSentinel
    | Undecided -> so_far

    | Ptr(pointed_t) -> _get_tvars so_far pointed_t

    | ByteArray(actual_t) -> _get_tvars so_far actual_t

    | Tuple(tuple_typs) ->
        List.fold_left _get_tvars so_far tuple_typs

    | Array(typ, _) ->
        _get_tvars so_far typ

    | Variant(_, ctors) ->
        List.fold_left _get_tvars_in_v_ctor so_far ctors

    | Function(ret_t, args_t_lst) ->
        let so_far = _get_tvars so_far ret_t in
        let so_far =
          List.fold_left (
            fun so_far arg_t -> _get_tvars so_far arg_t
          ) so_far args_t_lst
        in
        so_far
  in

  let tvars = _get_tvars [] typ in

  List.sort_uniq compare tvars
;;

(* Get the index of the given ctor name in the given list of variant ctors *)
let get_tag_index_by_variant_ctor v_t ctor_name =
  let v_ctors =
    begin match v_t with
    | Variant(_, v_ctors) -> v_ctors
    | _ ->
        failwith (
          Printf.sprintf "Unexpected non-variant type [%s] in [%s]"
            (fmt_type v_t)
            (__FUNCTION__)
        )
    end
  in

  let rec _get_variant_ctor_tag_index accum v_ctors_tail =
    begin match v_ctors_tail with
    | [] -> failwith ("Failed to find " ^ ctor_name ^ " within variant")
    | {name; _}::xs ->
        begin if name = ctor_name then
          accum
        else
          _get_variant_ctor_tag_index (accum + 1) xs
        end
    end
  in

  _get_variant_ctor_tag_index 0 v_ctors
;;

(* Get the index of the given ctor name in the given list of variant ctors *)
let get_variant_ctor_by_tag_index v_ctors idx =
  List.nth v_ctors idx
;;
