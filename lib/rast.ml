open Ast
open Typing
open Ir
open Utility

(*
Reduced-complexity AST.

Various elements of the full AST, generated by parse and used for typechecking,
can be rewritten in a more explicit but simpler form. This allows for easier
further analysis once the input is deemed well-formed, and easier generation
of MIR.

This reduced form of the AST deliberately loses certain information, like:

  - Limited scoping of variables.
  - Modifiers on variables, like mutability.

as it is assumed that the input AST was already verified as being well-formed.
*)

type rast_t =
  | U64
  | U32
  | U16
  | U8
  | I64
  | I32
  | I16
  | I8
  | F128
  | F64
  | F32
  | Bool
  | String
  | Nil
  | Tuple of rast_t list
  (* A superposition of multiple tuples, where only one actually exists as a
  value at any one time. The overall size of this type is the size of the
  largest superimposed tuple. Essentially an untagged union but requiring each
  "superimposed type" to itself be a tuple. *)
  | SuperTuple of rast_t list list
  | Array of rast_t * int
  | Ptr of rast_t
  | Function of rast_t * rast_t list
  | VarArgSentinel
  (* This is not generated by the front-end, but may be generated during
  lowering to indicate "the type of this data is actually the [N x i8] raw
  form of this type. " *)
  | ByteArray of rast_t

type rexpr =
  | RValNil
  | RValF128 of string
  | RValF64 of float
  | RValF32 of float
  | RValBool of bool
  | RValStr of string
  | RValInt of rast_t * int

  (* A typical variable. *)
  | RValVar of rast_t * string

  (* A variable that represents a function as a first-class value. *)
  | RValFunc of rast_t * string

  | RValRawArray of rast_t

  | RValCast of rast_t * cast_op * rexpr
  | RUnOp of rast_t * un_op * rexpr
  | RBinOp of rast_t * bin_op * rexpr * rexpr

  | RBlockExpr of rast_t * rstmt * rexpr

  | RExprInvoke of rast_t * rexpr * rexpr list

  | RArrayExpr of rast_t * rexpr list
  | RIndexExpr of rast_t * rexpr * rexpr

  | RTupleIndexExpr of rast_t * int * rexpr
  | RTupleExpr of rast_t * rexpr list

  | RMatchExpr of rast_t * rexpr * (rpattern * rexpr) list

  (* TODO: This can almost certainly be simplified into being in terms of
  a series of init stmts, a bare loop construct (that we could re-use elsewhere
  as well, eg `for-loop` constructs), and an initial check at the beginning
  of the loop for whether or not to break to the end. *)
  | RWhileExpr of rast_t * rstmt list * rexpr * rstmt list

and rpattern =
  | RWild of rast_t
  | RVarBind of rast_t * string
  | RPNil
  | RPBool of bool
  | RPIntLit of rast_t * int
  | RPIntFrom of rast_t * int
  | RPIntUntil of rast_t * int
  | RPIntRange of rast_t * int * int
  | RPTuple of rast_t * rpattern list
  (* Reinterpret the matchee as the given type, and then apply the given
  pattern. *)
  | RPCastThen of rast_t * cast_op * rpattern
  (* Match the matchee against the given pattern, but also bind a variable of
  the given name to the matchee. *)
  | RPatternAs of rast_t * rpattern * string

and rassign_idx_lval =
  (* An index into a tuple. The type is of the result, after the index. *)
  | RALStaticIndex of rast_t * int
  (* An index into a static or dynamic array. The type is of the result, after
  the index.*)
  | RALIndex of rast_t * rexpr

and rstmt =
  | RDeclStmt of string * rast_t * rexpr

  | RDeclDefStmt of (string * rast_t) list

  (* Type is the type of the RHS expression. Note that this may not be exactly
  the type of the actual target variable, but prior typechecking implies it's
  at least implicitly convertible. *)
  | RAssignStmt of string * rast_t * rassign_idx_lval list * rexpr

  | RExprStmt of rexpr
  | RReturnStmt of rexpr

  (* A convenience container for when a stmt needs to be rewritten using
  multiple rstmt. *)
  | RStmts of rstmt list

and rf_param = (ident_t * rast_t)

and rfunc_decl_t = {
  rf_name: string;
  rf_params: rf_param list;
  rf_ret_t: rast_t;
}

and rfunc_def_t = {
  rf_decl: rfunc_decl_t;
  rf_stmts: rstmt list;
}
;;

let (variant_tag_rt : rast_t) = U8;;

let rec berk_t_to_rast_t (t : berk_t) : rast_t =
  begin match t with
  | U64 -> U64
  | U32 -> U32
  | U16 -> U16
  | U8 -> U8
  | I64 -> I64
  | I32 -> I32
  | I16 -> I16
  | I8 -> I8
  | F128 -> F128
  | F64 -> F64
  | F32 -> F32
  | Bool -> Bool
  | String -> String
  | Nil -> Nil
  | VarArgSentinel -> VarArgSentinel

  | Ptr(pointed_t) ->
      let pointed_rt = berk_t_to_rast_t pointed_t in
      Ptr(pointed_rt)

  | Tuple(elem_ts) ->
      let elem_rts = List.map berk_t_to_rast_t elem_ts in
      Tuple(elem_rts)

  | Array(elem_t, i) ->
      let elem_rt = berk_t_to_rast_t elem_t in
      Array(elem_rt, i)

  | Variant(_, v_ctor_xs) ->
      let _ = if List.length v_ctor_xs > 255 then
        failwith "Variants with >255 constructors not implemented"
      else
        ()
      in

      let ctor_tuples = List.map v_ctor_as_tagged_type_list v_ctor_xs in

      SuperTuple(ctor_tuples)

  | Function(ret_t, args_ts) ->
      let ret_rt = berk_t_to_rast_t ret_t in
      let args_rts = List.map berk_t_to_rast_t args_ts in
      Function(ret_rt, args_rts)

  (* These types should have been eliminated during AST typechecking. *)
  | UnboundType(_, _)
  | Unbound(_)
  | Undecided ->
      failwith (
        Printf.sprintf "Error: Unexpected type during RAST lowering: %s"
        (fmt_type t)
      )
  end

(* Yield the tuple type that represents the given variant constructor, including
the prefixed implicit constructor tag. *)
and v_ctor_as_tagged_type_list {fields; _} : rast_t list =
  let fields_ts = List.map (fun {t} -> berk_t_to_rast_t t) fields in
  variant_tag_rt :: fields_ts
;;

let rexpr_type exp =
  begin match exp with
  | RValNil -> Nil
  | RValF128(_) -> F128
  | RValF64(_)  -> F64
  | RValF32(_)  -> F32
  | RValBool(_) -> Bool
  | RValStr(_) -> String
  | RValInt(typ, _) -> typ
  | RValVar(typ, _) -> typ
  | RValFunc(typ, _) -> typ
  | RValRawArray(typ) -> typ
  | RValCast(typ, _, _) -> typ
  | RUnOp(typ, _, _) -> typ
  | RBinOp(typ, _, _, _) -> typ
  | RBlockExpr(typ, _, _) -> typ
  | RWhileExpr(typ, _, _, _) -> typ
  | RExprInvoke(typ, _, _) -> typ
  | RArrayExpr(typ, _) -> typ
  | RIndexExpr(typ, _, _) -> typ
  | RTupleIndexExpr(typ, _, _) -> typ
  | RTupleExpr(typ, _) -> typ
  | RMatchExpr(typ, _, _) -> typ
  end
;;

let rec expr_to_rexpr expr : rexpr =
  begin match expr with
  | ValName(_, name) ->
      failwith (
        Printf.sprintf
          "Error: Cannot convert ValName(%s) to rexpr: must be pre-resolved"
          name
      )

  | ValNil -> RValNil
  | ValF128(s) -> RValF128(s)
  | ValF64(f) -> RValF64(f)
  | ValF32(f) -> RValF32(f)
  | ValBool(b) -> RValBool(b)
  | ValStr(s) -> RValStr(s)
  | ValInt(t, i) ->
      let rt = berk_t_to_rast_t t in
      RValInt(rt, i)

  | ValVar(t, name) ->
      let rt = berk_t_to_rast_t t in
      RValVar(rt, name)
  | ValFunc(t, name) ->
      let rt = berk_t_to_rast_t t in
      RValFunc(rt, name)

  | ValRawArray(t) ->
      let rt = berk_t_to_rast_t t in
      RValRawArray(rt)

  | ValCast(t, op, e) ->
      let rt = berk_t_to_rast_t t in
      let re = expr_to_rexpr e in
      RValCast(rt, op, re)

  | UnOp(t, op, e) ->
      let rt = berk_t_to_rast_t t in
      let re = expr_to_rexpr e in
      RUnOp(rt, op, re)

  | BinOp(t, op, e_lhs, e_rhs) ->
      let rt = berk_t_to_rast_t t in
      let re_lhs = expr_to_rexpr e_lhs in
      let re_rhs = expr_to_rexpr e_rhs in
      RBinOp(rt, op, re_lhs, re_rhs)

  | BlockExpr(t, stmts, e) ->
      let rt = berk_t_to_rast_t t in
      let re = expr_to_rexpr e in
      let rstmts = List.map stmt_to_rstmt stmts in
      let wrapped_rstmts = RStmts(rstmts) in
      RBlockExpr(rt, wrapped_rstmts, re)

  | ExprInvoke(t, e_func, e_args) ->
      let rt = berk_t_to_rast_t t in
      let re_func = expr_to_rexpr e_func in
      let re_args = List.map expr_to_rexpr e_args in
      RExprInvoke(rt, re_func, re_args)

  | FuncCall(t, name, e_args) ->
      let rt = berk_t_to_rast_t t in
      let args_rts =
        List.map (
          fun e_arg ->
            let expr_t = expr_type e_arg in
            berk_t_to_rast_t expr_t
        ) e_args
      in
      let func_rt = Function(rt, args_rts) in
      let re_func = RValFunc(func_rt, name) in

      let re_args = List.map expr_to_rexpr e_args in

      RExprInvoke(rt, re_func, re_args)

  | UfcsCall(t, e_arg_first, name, e_args_rest) ->
      let e_args_all = e_arg_first :: e_args_rest in

      let rewritten_as_func_call = FuncCall(t, name, e_args_all) in

      expr_to_rexpr rewritten_as_func_call

  | ArrayExpr(t, e_elems) ->
      let rt = berk_t_to_rast_t t in
      let re_elems = List.map expr_to_rexpr e_elems in
      RArrayExpr(rt, re_elems)

  | IndexExpr(t, e_idx, e_arr) ->
      let rt = berk_t_to_rast_t t in
      let re_idx = expr_to_rexpr e_idx in
      let re_arr = expr_to_rexpr e_arr in
      RIndexExpr(rt, re_idx, re_arr)

  | TupleIndexExpr(t, i, e_tuple) ->
      let rt = berk_t_to_rast_t t in
      let re_tuple = expr_to_rexpr e_tuple in
      RTupleIndexExpr(rt, i, re_tuple)

  | TupleExpr(t, e_elems) ->
      let rt = berk_t_to_rast_t t in
      let re_elems = List.map expr_to_rexpr e_elems in
      RTupleExpr(rt, re_elems)

  | VariantCtorExpr(t, ctor_name, e_fields) ->
      (* "Type-erase" the value of the variant constructor into (what's expected
      to be) a union type. *)
      let rt = berk_t_to_rast_t t in

      let ctor_tuple = begin
        let ctor_idx = get_tag_index_by_variant_ctor t ctor_name in
        let ctor_idx_rexpr = RValInt(variant_tag_rt, ctor_idx) in

        let ctor_accessible_fields = List.map expr_to_rexpr e_fields in
        let ctor_all_fields = ctor_idx_rexpr :: ctor_accessible_fields in

        let tuple_ts = List.map rexpr_type ctor_all_fields in
        let tuple_t = Tuple(tuple_ts) in

        RTupleExpr(tuple_t, ctor_all_fields)
      end in

      RValCast(rt, Bitwise, ctor_tuple)

  | IfThenElseExpr(t, e_cond, e_then, e_else) ->
      let rt = berk_t_to_rast_t t in
      let re_cond = expr_to_rexpr e_cond in
      let re_then = expr_to_rexpr e_then in
      let re_else = expr_to_rexpr e_else in
      RMatchExpr(rt, re_cond, [(RPBool(true), re_then); (RWild(Bool), re_else)])

  | WhileExpr(t, stmts_init, e_cond, stmts_block) ->
      let rt = berk_t_to_rast_t t in
      let rstmts_init = List.map stmt_to_rstmt stmts_init in
      let rstmts_block = List.map stmt_to_rstmt stmts_block in
      let re_cond = expr_to_rexpr e_cond in
      RWhileExpr(rt, rstmts_init, re_cond, rstmts_block)

  | MatchExpr(t, e_cond, patts_to_exprs) ->
      let rt = berk_t_to_rast_t t in
      let re_cond = expr_to_rexpr e_cond in
      let rpatts_to_rexprs =
        List.map (
          fun (patt, expr) ->
            let rpatt = pattern_to_rpattern patt in
            let rexpr = expr_to_rexpr expr in
            (rpatt, rexpr)
        ) patts_to_exprs
      in
      RMatchExpr(rt, re_cond, rpatts_to_rexprs)
  end

and pattern_to_rpattern patt : rpattern =
  begin match patt with
  | PNil -> RPNil

  | Wild(t) ->
      let rt = berk_t_to_rast_t t in
      RWild(rt)

  | VarBind(t, name) ->
      let rt = berk_t_to_rast_t t in
      RVarBind(rt, name)

  | PBool(b) -> RPBool(b)

  | PInt(t, IRangeLiteral(i)) ->
      let rt = berk_t_to_rast_t t in
      RPIntLit(rt, i)

  | PInt(t, IRangeAllFrom(i)) ->
      let rt = berk_t_to_rast_t t in
      RPIntFrom(rt, i)

  | PInt(t, IRangeAllUntil(i)) ->
      let rt = berk_t_to_rast_t t in
      RPIntUntil(rt, i)

  | PInt(t, IRangeFromUntil(i, j)) ->
      let rt = berk_t_to_rast_t t in
      RPIntRange(rt, i, j)

  | PInt(_, IRangeAll) -> failwith "IRangeAll should not survive typecheck"

  | PTuple(t, patts) ->
      let rt = berk_t_to_rast_t t in
      let rpatts = List.map pattern_to_rpattern patts in
      RPTuple(rt, rpatts)

  | Ctor(t, ctor_name, patts) ->
      (* The variant value will come to us as a "type-erased" union type, that
      we'll need to (attempt to) bitwise-cast into a specific constructor tuple
      pattern. *)

      let ctor_tuple_t = begin
        let v_ctor = get_v_ctor t ctor_name in
        let ctor_tuple_ts = v_ctor_as_tagged_type_list v_ctor in
        Tuple(ctor_tuple_ts)
      end in

      let tuple_patt = begin
        let idx = get_tag_index_by_variant_ctor t ctor_name in
        let rpatts = List.map pattern_to_rpattern patts in
        let tuple_rpatts = RPIntLit(variant_tag_rt, idx) :: rpatts in

        RPTuple(ctor_tuple_t, tuple_rpatts)
      end in

      RPCastThen(ctor_tuple_t, Bitwise, tuple_patt)

  | PatternAs(t, patt, name) ->
      let rt = berk_t_to_rast_t t in
      let rpatt = pattern_to_rpattern patt in
      RPatternAs(rt, rpatt, name)
  end

and assign_idx_lval_to_rassign_idx_lval idx : rassign_idx_lval =
  begin match idx with
  | ALStaticIndex(indexed_t, i) ->
      let indexed_rt = berk_t_to_rast_t indexed_t in
      RALStaticIndex(indexed_rt, i)

  | ALIndex(indexed_t, e) ->
      let indexed_rt = berk_t_to_rast_t indexed_t in
      let re = expr_to_rexpr e in
      RALIndex(indexed_rt, re)
  end

and stmt_to_rstmt stmt : rstmt =
  begin match stmt with
  | ExprStmt(_, e) ->
      let re = expr_to_rexpr e in
      RExprStmt(re)

  | ReturnStmt(e) ->
      let re = expr_to_rexpr e in
      RReturnStmt(re)

  | DeclStmt(name, _, t, e) ->
      let rt = berk_t_to_rast_t t in
      let re = expr_to_rexpr e in
      RDeclStmt(name, rt, re)

  | DeclDefStmt(names_quals_ts) ->
      let names_rts =
        List.map (
          fun (name, _, t) ->
            let rt = berk_t_to_rast_t t in
            (name, rt)
        ) names_quals_ts
      in
      RDeclDefStmt(names_rts)

  | AssignStmt(name, named_t, idxs, e) ->
      let ridxs = List.map assign_idx_lval_to_rassign_idx_lval idxs in
      let named_rt = berk_t_to_rast_t named_t in
      let re = expr_to_rexpr e in
      RAssignStmt(name, named_rt, ridxs, re)

  (* Deconstructing `let` stmts can be described as first assigning the
  result of the expr-to-be-deconstructed to a placeholder named variable, and
  then performing a series of indexes onto that variable into the target
  "real" deconstructed variable names. *)
  | DeclDeconStmt(names_quals, t, e) ->
      let names = List.map (fun (name, _) -> name) names_quals in
      let rt = berk_t_to_rast_t t in
      let re = expr_to_rexpr e in

      let placeholder_name = Printf.sprintf "__%s" (fmt_join_strs "_" names) in

      let init_rstmt = RDeclStmt(placeholder_name, rt, re) in
      let decon_rstmts =
        begin match t with
        | Tuple(ts) ->
            map2i (
              fun i name elem_t ->
                let elem_rt = berk_t_to_rast_t elem_t in
                RDeclStmt(
                  name, elem_rt,
                  RTupleIndexExpr(elem_rt, i, RValVar(rt, placeholder_name))
                )
            ) names ts

        | _ ->
            failwith "Cannot rewrite deconstruction of non-tuple decl."
        end
      in
      RStmts(init_rstmt :: decon_rstmts)
  end

and f_param_to_rf_param (name, _, t) =
  let rt = berk_t_to_rast_t t in
  (name, rt)

and func_decl_t_to_rfunc_decl_t {f_name; f_params; f_ret_t} =
  let rf_params = List.map f_param_to_rf_param f_params in
  let rf_ret_rt = berk_t_to_rast_t f_ret_t in
  {rf_name=f_name; rf_params=rf_params; rf_ret_t=rf_ret_rt}

and func_def_t_to_rfunc_def_t {f_decl; f_stmts} =
  let rf_decl = func_decl_t_to_rfunc_decl_t f_decl in
  let rf_stmts = List.map stmt_to_rstmt f_stmts in
  {rf_decl=rf_decl; rf_stmts=rf_stmts}
;;

let rec fmt_join_types delim types =
  begin match types with
  | [] -> ""
  | [x] -> fmt_rtype x
  | x::xs ->
      let lhs = fmt_rtype x in
      lhs ^ delim ^ (fmt_join_types delim xs)
  end

and fmt_rtype (rast_type : rast_t) : string =
  begin match rast_type with
  | U64 -> "u64"
  | U32 -> "u32"
  | U16 -> "u16"
  | U8  -> "u8"
  | I64 -> "i64"
  | I32 -> "i32"
  | I16 -> "i16"
  | I8  -> "i8"
  | F128 -> "f128"
  | F64  -> "f64"
  | F32  -> "f32"
  | Bool -> "bool"
  | String -> "string"
  | Nil -> "()"
  | VarArgSentinel -> "..."

  | Array (typ, sz) ->
      Printf.sprintf "[%s x %d]" (fmt_rtype typ) sz

  | Tuple (types) ->
      let tuple_fmt = fmt_join_types ", " types in
      Printf.sprintf "(%s)" tuple_fmt

  | SuperTuple (tss) ->
      let tuples = List.map (fun ts -> Tuple(ts)) tss in
      let tuple_fmt_xs = List.map fmt_rtype tuples in
      let tuples_fmt = fmt_join_strs " | " tuple_fmt_xs in
      Printf.sprintf "(%s)" tuples_fmt

  | Ptr (typ) ->
      Printf.sprintf "ptr %s"
        (fmt_rtype typ)

  | ByteArray (typ) ->
      Printf.sprintf "bytesof(%s)"
        (fmt_rtype typ)

  | Function (ret_t, arg_t_lst) ->
      Printf.sprintf "(%s)->%s"
        (fmt_join_types ", " arg_t_lst)
        (fmt_rtype ret_t)
  end

let rec fmt_rexpr ?(init_ind=false) ?(ind="") ?(print_typ = false) re : string =
  let init_ind = if init_ind then ind else "" in
  let (typ_s, typ_s_rev) =
    if print_typ
    then
      let typ_formatted = rexpr_type re |> fmt_rtype in
      (Printf.sprintf ":%s" typ_formatted, Printf.sprintf "%s:" typ_formatted)
    else ("", "")
  in
  begin match re with
  | RValNil -> Printf.sprintf "%sRValNil()%s" init_ind typ_s

  | RValF128(str) -> Printf.sprintf "%sRValF128(%s)%s" init_ind str typ_s

  | RValF64(value) -> Printf.sprintf "%sRValF64(%f)%s" init_ind value typ_s
  | RValF32(value) -> Printf.sprintf "%sRValF32(%f)%s" init_ind value typ_s

  | RValBool(value) -> Printf.sprintf "%sRValBool(%B)%s" init_ind value typ_s

  | RValStr(str) ->
      (* The string we have here is the raw parsed string, so `\n` is still
      "\n". Nevertheless sprintf will try to helpfully replace the escape code
      with the actual newline, so we escape it deliberately before printing. *)
      Printf.sprintf "%sRValStr(\"%s\")%s" init_ind (String.escaped str) typ_s

  | RValInt(_, value) ->
      Printf.sprintf "%sRValInt(%d)%s" init_ind value typ_s

  | RValVar(_, id) -> Printf.sprintf "%sRValVar(%s)%s" init_ind id typ_s

  | RValFunc(_, func_name) ->
      Printf.sprintf "%sfn<%s%s>" init_ind func_name typ_s

  | RValRawArray(rt) ->
      Printf.sprintf "%s<uninitialized of %s>%s"
        init_ind (fmt_rtype rt) typ_s

  | RValCast(target_rt, op, exp) ->
      let op_fmt = fmt_cast_op op in
      Printf.sprintf "%scast_%s<%s>(%s)%s"
        init_ind
        op_fmt
        (fmt_rtype target_rt)
        (fmt_rexpr ~print_typ:print_typ exp)
        typ_s

  | RUnOp (_, op, exp) ->
      Printf.sprintf "%s(%s %s)%s"
        init_ind
        (fmt_un_op op)
        (fmt_rexpr ~print_typ:print_typ exp)
        typ_s

  | RBinOp (_, op, lh, rh) ->
      Printf.sprintf "%s(%s %s %s)%s"
        init_ind
        (fmt_rexpr ~print_typ:print_typ lh)
        (fmt_bin_op op)
        (fmt_rexpr ~print_typ:print_typ rh)
        typ_s

  | RBlockExpr (_, stmt, exp) ->
      let formatted_stmt = fmt_rstmt ~print_typ:print_typ (ind ^ "  ") stmt in
      Printf.sprintf "%sRBlockExpr(%s{\n%s%s\n%s})"
        init_ind
        typ_s_rev
        formatted_stmt
        (fmt_rexpr ~init_ind:true ~ind:(ind ^ "  ") ~print_typ:print_typ exp)
        ind

  | RWhileExpr (_, init_stmts, while_cond, then_stmts) ->
      let formatted_init_stmts = begin
        let (open_brace, close_brace, ind) =
          if List.length init_stmts = 0
          then ("", "", "")
          else ("{\n", Printf.sprintf "%s} in " ind, ind ^ "  ")
        in
        let formatted_stmts =
          List.fold_left (^) "" (
            List.map (fmt_rstmt ~print_typ:print_typ (ind)) init_stmts
          )
        in
        Printf.sprintf "%s%s%s" open_brace formatted_stmts close_brace
      end in

      let formatted_then_stmts =
        List.fold_left (^) "" (
          List.map (fmt_rstmt ~print_typ:print_typ (ind ^ "  ")) then_stmts
        )
      in

      Printf.sprintf "%s%swhile %s%s {\n%s%s}"
        init_ind
        typ_s_rev
        formatted_init_stmts
        (fmt_rexpr ~print_typ:print_typ while_cond)
        formatted_then_stmts
        ind

  | RExprInvoke(_, exp, exprs) ->
      Printf.sprintf "%s%sRExprInvoke(%s(%s))"
        init_ind
        typ_s_rev
        (fmt_rexpr ~print_typ:print_typ exp)
        (fmt_join_rexprs ~ind:ind ~print_typ:print_typ ", " exprs)

  | RArrayExpr(_, exprs) ->
      Printf.sprintf "%s[%s]%s"
        init_ind
        (fmt_join_rexprs ~ind:ind ~print_typ:print_typ ", " exprs)
        typ_s

  | RTupleIndexExpr(_, idx, arr) ->
      Printf.sprintf "%s%s.%d:%s"
        init_ind
        (fmt_rexpr ~print_typ:print_typ arr)
        idx
        typ_s

  | RIndexExpr(_, idx, arr) ->
      Printf.sprintf "%s%s[%s]:%s"
        init_ind
        (fmt_rexpr ~print_typ:print_typ arr)
        (fmt_rexpr ~print_typ:print_typ idx)
        typ_s

  | RTupleExpr(_, exprs) ->
      Printf.sprintf "%s(%s)%s"
        init_ind
        (fmt_join_rexprs ~ind:ind ~print_typ:print_typ ", " exprs)
        typ_s

  | RMatchExpr(_, matched_exp, pattern_exp_pairs) ->
      let pattern_exprs_fmt =
        List.fold_left (^) "" (
          List.map (
            fun (pattern, exp) ->
              let pattern_fmt =
                fmt_rpattern ~print_typ:print_typ ~init_ind:ind pattern
              in
              let exp_fmt =
                fmt_rexpr
                  ~init_ind:false ~ind:(ind ^ "  ") ~print_typ:print_typ exp
              in
              Printf.sprintf "%s -> %s\n" pattern_fmt exp_fmt
          ) pattern_exp_pairs
        )
      in
      Printf.sprintf "%s%smatch %s {\n%s%s}"
        init_ind
        typ_s_rev
        (fmt_rexpr ~print_typ:print_typ matched_exp)
        pattern_exprs_fmt
        ind
  end

and fmt_join_rexprs ?(ind = "") ?(print_typ = false) delim exprs : string =
  match exprs with
  | [] -> ""
  | [x] -> fmt_rexpr ~ind:ind ~print_typ:print_typ x
  | x::xs ->
      (fmt_rexpr ~ind:ind ~print_typ:print_typ x) ^ delim ^
      (fmt_join_rexprs ~ind:ind ~print_typ:print_typ delim xs)

and fmt_rpattern ?(print_typ=false) ?(init_ind="") rpatt =
  let open Printf in

  let _maybe_fmt_rtype rt =
    if print_typ then
      sprintf ":%s" (fmt_rtype rt)
    else
      ""
  in

  let rec _fmt_rpattern rpatt =
    begin match rpatt with
    | RPNil ->
        sprintf "<nil>"
    | RWild(rt) ->
        sprintf "_%s" (_maybe_fmt_rtype rt)
    | RVarBind(rt, var_name) ->
        sprintf "%s%s" var_name (_maybe_fmt_rtype rt)
    | RPBool(b) ->
        sprintf "%b%s" b (_maybe_fmt_rtype Bool)
    | RPIntLit(_, i) ->
        sprintf "(%d)" i
    | RPIntFrom(_, i) ->
        sprintf "(%d..)" i
    | RPIntUntil(_, i) ->
        sprintf "(..%d)" i
    | RPIntRange(_, i, j) ->
        sprintf "(%d..%d)" i j
    | RPTuple(rt, patterns) ->
        let patterns_fmt = List.map _fmt_rpattern patterns in
        sprintf "(%s)%s" (fmt_join_strs ", " patterns_fmt) (_maybe_fmt_rtype rt)
    | RPCastThen(rt, op, patt) ->
        let rt_fmt = fmt_rtype rt in
        let op_fmt = fmt_cast_op op in
        let patt_fmt = _fmt_rpattern patt in
        sprintf "<%s_cast<%s>, then match %s>" op_fmt rt_fmt patt_fmt
    | RPatternAs(t, pattern, var_name) ->
        sprintf
          "%s%s as %s"
          (_fmt_rpattern pattern)
          (_maybe_fmt_rtype t)
          var_name
    end
  in
  let rpattern_fmt = _fmt_rpattern rpatt in

  sprintf "%s| %s" init_ind rpattern_fmt

and fmt_join_idents_quals delim idents_quals : string =
  match idents_quals with
  | [] -> ""
  | [(ident, qual)] -> Printf.sprintf "%s%s" (fmt_var_qual qual) ident
  | (ident, qual)::xs ->
      Printf.sprintf "%s%s%s%s"
        (fmt_var_qual qual)
        ident
        delim
        (fmt_join_idents_quals delim xs)

and fmt_join_idents_types
  delim (idents_types : (ident_t * rast_t) list) : string =
  match idents_types with
  | [] -> ""

  | [(ident, rt)] ->
      Printf.sprintf "%s: %s" ident (fmt_rtype rt)

  | (ident, rt)::xs ->
      Printf.sprintf "%s: %s%s%s"
        ident
        (fmt_rtype rt)
        delim
        (fmt_join_idents_types delim xs)

and fmt_rassign_lval_idxs ?(print_typ = false) lval_idxs =
  let rec _fmt_rassign_lval_idxs lval_idxs_rem fmt_so_far =
    begin match lval_idxs_rem with
    | [] -> fmt_so_far
    | idx :: rest ->
        let fmt = fmt_rassign_lval_idx ~print_typ:print_typ idx in
        _fmt_rassign_lval_idxs rest (fmt_so_far ^ fmt)
    end
  in
  _fmt_rassign_lval_idxs lval_idxs ""

and fmt_rassign_lval_idx ?(print_typ = false) lval_idx =
  begin match lval_idx with
  | RALStaticIndex(t, i) ->
      let t_fmt = if print_typ then ":" ^ (fmt_rtype t) else "" in
      Printf.sprintf ".%d%s" i t_fmt

  | RALIndex(t, exp) ->
      let t_fmt = if print_typ then ":" ^ (fmt_rtype t) else "" in
      Printf.sprintf "[%s]%s" (fmt_rexpr ~print_typ:print_typ exp) t_fmt
  end

and fmt_rstmt ?(print_typ = false) ind rstmt =
  begin match rstmt with
  | RDeclStmt (ident, rt, ex) ->
      let typ_s = fmt_rtype rt |> Printf.sprintf ":%s" in
      Printf.sprintf "%slet %s%s = %s;\n"
        ind
        ident
        typ_s
        (fmt_rexpr ~ind:ind ~print_typ:print_typ ex)

  | RDeclDefStmt (idents_ts) ->
      Printf.sprintf "%slet %s;\n"
        ind
        (fmt_join_idents_types ", " idents_ts)

  | RAssignStmt (ident, rt, lval_idxs, ex) ->
      Printf.sprintf "%s%s:%s %s = %s;\n"
        ind
        ident
        (fmt_rtype rt)
        (fmt_rassign_lval_idxs ~print_typ:print_typ lval_idxs)
        (fmt_rexpr ~ind:ind ~print_typ:print_typ ex)

  | RExprStmt (ex) ->
      Printf.sprintf "%s%s;\n"
        ind
        (fmt_rexpr ~ind:ind ~print_typ:print_typ ex)

  | RReturnStmt (ex) ->
      Printf.sprintf "%sreturn %s;\n"
        ind
        (fmt_rexpr ~ind:ind ~print_typ:print_typ ex)

  | RStmts(stmts) ->
      let formatted_stmts = List.map (fmt_rstmt ind) stmts in
      Printf.sprintf "%s"
        (fmt_join_strs "" formatted_stmts)
  end

let rec fmt_rfunc_decl_t
  ?(print_typ = false) ?(extern = false) f_decl : string
=
  let maybe_extern =
    if extern
      then "extern "
      else ""
  in
  Printf.sprintf "%s%s;\n"
    maybe_extern
    (fmt_rfunc_decl_t_signature ~print_typ:print_typ f_decl)

and fmt_rfunc_decl_t_signature
  ?(print_typ = false) {rf_name; rf_params; rf_ret_t} : string
=
  let ret_t_s = begin match rf_ret_t with
    | Nil ->
        if print_typ
        then Printf.sprintf ": %s" (fmt_rtype rf_ret_t)
        else ""
    | _ -> Printf.sprintf ": %s" (fmt_rtype rf_ret_t)
  end in

  Printf.sprintf "fn %s(%s)%s"
    rf_name
    (fmt_join_func_params "," rf_params)
    ret_t_s

and fmt_rf_param (p_name, p_type) : string =
  Printf.sprintf "%s: %s"
    p_name
    (fmt_rtype p_type)

and fmt_join_func_params delim params : string =
  match params with
  | [] -> ""
  | [x] -> fmt_rf_param x
  | x::xs ->
      Printf.sprintf "%s%s %s"
        (fmt_rf_param x)
        delim
        (fmt_join_func_params delim xs)

and fmt_rfunc_def_t ?(print_typ = false) {rf_decl; rf_stmts;} : string =
  let formatted_stmts =
    List.fold_left (^) "" (
      List.map (fmt_rstmt ~print_typ:print_typ "  ") rf_stmts
    )
  in

  Printf.sprintf "%s {\n%s}\n"
    (fmt_rfunc_decl_t_signature ~print_typ:print_typ rf_decl)
    formatted_stmts
;;


let unwrap_indexable (indexable_t : rast_t) =
  match indexable_t with
  | Array(t, _) -> t
  | _ ->
      failwith (
        Printf.sprintf "Cannot unwrap non-indexable type: [%s]"
          (fmt_rtype indexable_t)
      )
;;


let unwrap_ptr (ptr_t : rast_t) =
  match ptr_t with
  | Ptr(t) -> t
  | Array(t, _) -> t
  | _ ->
      failwith (
        Printf.sprintf "Cannot unwrap non-ptr type [%s]" (fmt_rtype ptr_t)
      )
;;


let unwrap_aggregate_indexable (indexable_t : rast_t) i =
  match indexable_t with
  | Tuple(ts) ->
      if i < List.length ts then
        List.nth ts i
      else
        failwith (Printf.sprintf "Invalid index into tuple of arity [%d]" i)

  | _ ->
      failwith (
        Printf.sprintf "Cannot unwrap non-indexable aggregate type: [%s]"
          (fmt_rtype indexable_t)
      )
;;


(* TODO: This is not the most appropriate place for this function, because
really the backend code generator (eg, LLVM) should be the one making decisions
about the relative sizes of types (particularly because of alignment between
fields in aggregate types). We keep this here now while we lack a sufficient
abstraction mechanism to punt this to the backend side. *)
let rec sizeof_rtype (t : rast_t) =
  begin match t with
  | Function(_, _) -> 16
  (* FIXME: Not true yet, but will be if/when function ptrs become fat ptrs. *)
  | F128 -> 16
  | Ptr(_) -> 8
  | U64 | I64 | F64 -> 8
  | U32 | I32 | F32 -> 4
  | U16 | I16 -> 2
  | U8  | I8 -> 1
  | String -> 4
  | Bool -> 1
  | Nil -> 0

  | Tuple(ts) -> sum (List.map sizeof_rtype ts)
  | Array(t, sz) -> sz * (sizeof_rtype t)

  | SuperTuple(tss) ->
      (* The size of this type is the size of the largest superimposed tuple. *)
      let tuples = List.map (fun ts -> Tuple(ts)) tss in
      let sizes = List.map sizeof_rtype tuples in
      List.fold_left max 0 sizes

  | ByteArray(_)
  | VarArgSentinel ->
      failwith (
        Printf.sprintf "Invalid to attempt sizeof_rtype([%s])" (fmt_rtype t)
      )
  end
;;


(* Determine the common type between two. ie, if they're not the same type, but
one is convertible to the other, yield the common type. *)
let rec common_type_of_lr (lhs : rast_t) (rhs : rast_t) =
  let _common_type_of_lr lhs rhs =
    match (lhs, rhs) with
    | (Nil,              Nil) -> Some(Nil)
    | ((I64|I32|I16|I8), I64) -> Some(I64)
    | ((I32|I16|I8),     I32) -> Some(I32)
    | ((I16|I8),         I16) -> Some(I16)
    | (I8,               I8 ) -> Some(I8)
    | ((U64|U32|U16|U8), U64) -> Some(U64)
    | ((U32|U16|U8),     U32) -> Some(U32)
    | ((U16|U8),         U16) -> Some(U16)
    | (U8,               U8 ) -> Some(U8)
    | ((F128|F64|F32),  F128) -> Some(F128)
    | ((F64|F32),       F64 ) -> Some(F64)
    | (F32,             F32 ) -> Some(F32)
    | (Bool,            Bool) -> Some(Bool)
    | (String,        String) -> Some(String)

    | (Tuple(lhs_typs), Tuple(rhs_typs)) ->
        let common_tup_typs = List.map2 common_type_of_lr lhs_typs rhs_typs in
        Some(Tuple(common_tup_typs))

    | (Array(lhs_elem_typ, lhs_sz), Array(rhs_elem_typ, rhs_sz)) ->
        if lhs_sz = rhs_sz then
          let common_elem_typ = common_type_of_lr lhs_elem_typ rhs_elem_typ in
          Some(Array(common_elem_typ, lhs_sz))
        else
          None

    | (SuperTuple(lhs_tss), SuperTuple(rhs_tss)) ->
        if (List.compare_lengths lhs_tss rhs_tss) = 0 then
          let common_tss =
            let lhs_tuples = List.map (fun ts -> Tuple(ts)) lhs_tss in
            let rhs_tuples = List.map (fun ts -> Tuple(ts)) rhs_tss in
            let common_tuples =
              List.map2 common_type_of_lr lhs_tuples rhs_tuples
            in
            List.map (
              fun common_tuple ->
                begin match common_tuple with
                | Tuple(ts) -> ts
                | _ -> failwith "Assert: Impossible: SuperTuple"
                end
            ) common_tuples
          in
          Some(SuperTuple(common_tss))
        else
          None

    | _ -> None
  in
  match _common_type_of_lr lhs rhs with
  | Some(t) -> t
  | None ->
    match _common_type_of_lr rhs lhs with
    | Some(t) -> t
    | None ->
        let lhs_fmt = fmt_rtype lhs in
        let rhs_fmt = fmt_rtype rhs in
        failwith (
          "No common type between [[" ^ lhs_fmt ^ "]] [[" ^ rhs_fmt ^ "]]"
        )

and common_type_of_lst lst =
  match lst with
  | [] -> Nil
  | [x] -> x
  | x::xs -> List.fold_left common_type_of_lr x xs
;;

(* Get the list of types among a list-list that yield the largest total tuple
type size. *)
let get_largest_tuple (tss : rast_t list list) : rast_t list =
  let size_to_tuple_ts =
    List.map (
      fun ts ->
        let sz = sizeof_rtype (Tuple(ts)) in
        (sz, ts)
    ) tss
  in

  let (_, largest_tuple_ts) =
    List.fold_left (
      fun (max_sz_so_far, max_tup_so_far) (cur_sz, cur_tup) ->
        begin
          if max_sz_so_far < cur_sz then
            (cur_sz, cur_tup)
          else
            (max_sz_so_far, max_tup_so_far)
        end
    ) (0, []) size_to_tuple_ts
  in

  largest_tuple_ts
;;

(* Do two types exactly match. *)
let rec is_same_type (lhs : rast_t) (rhs : rast_t) : bool =
  begin match (lhs, rhs) with
  | (U64, U64)
  | (U32, U32)
  | (U16, U16)
  | (U8, U8)
  | (I64, I64)
  | (I32, I32)
  | (I16, I16)
  | (I8, I8)
  | (F128, F128)
  | (F64, F64)
  | (F32, F32)
  | (Bool, Bool)
  | (String, String)
  | (Nil, Nil)
  | (VarArgSentinel, VarArgSentinel) ->
      true

  | (Ptr(lhs), Ptr(rhs))
  | (ByteArray(lhs), ByteArray(rhs)) ->
      is_same_type lhs rhs

  | (Array(lhs_t, lhs_i), Array(rhs_t, rhs_i)) ->
      (lhs_i = rhs_i) && (is_same_type lhs_t rhs_t)

  | (Tuple(lhs_ts), Tuple(rhs_ts)) ->
      begin if (List.compare_lengths lhs_ts rhs_ts) = 0 then
        List.for_all2 is_same_type lhs_ts rhs_ts
      else
        false
      end

  | (SuperTuple(lhs_tss), SuperTuple(rhs_tss)) ->
      let lhs_tuples = List.map (fun ts -> Tuple(ts)) lhs_tss in
      let rhs_tuples = List.map (fun ts -> Tuple(ts)) rhs_tss in
      begin if (List.compare_lengths lhs_tuples rhs_tuples) = 0 then
        List.for_all2 is_same_type lhs_tuples rhs_tuples
      else
        false
      end

  | (Function(lhs_ret_t, lhs_arg_ts), Function(rhs_ret_t, rhs_arg_ts)) ->
      (is_same_type lhs_ret_t rhs_ret_t) &&
      ((List.compare_lengths lhs_arg_ts rhs_arg_ts) = 0) &&
      (List.for_all2 is_same_type lhs_arg_ts rhs_arg_ts)

  | _ ->
      false
  end

(* Do two types match with respect to how bitwise casts would treat them in
practice. *)
and is_bitwise_same_type lhs rhs =
  begin match (lhs, rhs) with
  (* Handle the edge-case where the a super-tuple can be considered the same
  type as a classic tuple if the largest superimposed tuple matches the classic
  tuple. *)
  | ((Tuple(_) as classic_tup), SuperTuple(tss)) ->
      let quantum_tup = Tuple(get_largest_tuple tss) in
      is_same_type classic_tup quantum_tup

  | (SuperTuple(tss), (Tuple(_) as classic_tup)) ->
      let quantum_tup = Tuple(get_largest_tuple tss) in
      is_same_type classic_tup quantum_tup

  | (_, _) ->
      is_same_type lhs rhs
  end
